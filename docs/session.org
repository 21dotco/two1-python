Here's a sample two1 session:

1. Install it - one option is the single file install like this:

#+BEGIN_EXAMPLE
$ wget two1.com # shortcut for wget 21.co/two1 or two1.21.co or twoone.com
#+END_EXAMPLE

The other option is `pip3 install two1`

2. Do help to confirm it works

#+BEGIN_EXAMPLE
$ two1 --help
#+END_EXAMPLE

3. Get some bitcoin
   - faucet, but with a reminder (store it in a fake wallet locally)
   - mining, which requires authorization and pairing your chip
   - exchange, which requires purchasing with bank account/credit card
   - earning, which means booting up your server (can we send command line
     text-based  AWS job to rate-limit the faucet?)

#+BEGIN_EXAMPLE
$ two1 get --faucet
  # get some bitcoin
  # implements exponential backoff so that you get less and less over time

$ two1 get --mine
  # Convenience function to get bitcoin through mining

$ two1 get --exchange
  # Webbrowser open that URL

$ two1 get --earn
  # a) command line tasks to do to earn Bitcoin (?) Frontend of MTurk.
  # b) webbrowser tasks to do to earn Bitcoin (?)
#+END_EXAMPLE

3. Mine some bitcoin

#+BEGIN_EXAMPLE
  $ two1 mine
  # Probably no configuration parameters necessary here, but can confirm with
  # Ivan and Veer. We can set the config parameters (like the mining server to pair with) as defaults.
  
  # First time invoked on a 21 Bitcoin Node: it should pair with the server and
  # start continuously mining in the background as a daemon.
  
  # Second time and subsequent times invoked: it should say that it's active and show the mining status
  # (i.e. the amount of BTC mined to this point, etc)

  # One implication: `two1 mine` is running in the background as two1 is invoked for other purposes.

  # On a piece of hardware that is not a 21 Bitcoin Node, should say that
  # no mining chip is detected, and prompt someone to go and get a node at 21.co
  #
  # NOTE: this will mean we need some kind of system parameter (test if the /dev/bitcoin
  # exists) that will distinguish something that can mine from something
  # that cannot.   
#+END_EXAMPLE

4. See how much you have:

#+BEGIN_EXAMPLE
$ two1 status
Wallet (total)
  - addressN: balanceN: (private keys)

Mining (total received)
  - time paired, shares sent, total BTC received

Endpoints (total received)
  - URL: # requests : amt received : USD equivalent
| URL               |        IP | Port | Price | Name       | MMM? | Description        | # Requests | Satoshis Received | USD equivalent |
|-------------------+-----------+------+-------+------------+------+--------------------+------------+-------------------+----------------|
| example.com/en2cn | 127.0.0.1 | 8000 |  1000 | two1.en2cn | No   | English to Chinese |         27 |             27000 | $0.08          |
| example.com/en2es | 127.0.0.1 | 8000 |  2000 | two1.en2es | No   | English to Spanish |         33 |             33000 | $0.099         |

$ two1 status --private (shows the private keys for the wallet)
#+END_EXAMPLE

5. Search the Many Machine Market to see what's out there

#+BEGIN_EXAMPLE
  $ two1 search
  
  # TODO: need a demo mmm.json file as a stub database. Start with our existing
  # MMM endpoints. Make say 3-5 per. Search is just keyword based search on
  # descriptions. Uses tp to list in nice separated format.
  #   translation
  #      en2cn
  #        example.com/en2cn
  #        foo.com/en2cn
  #      en2es
  #        example.com/en2es
  #        foo.com/en2es
  #        bar.com/en2es
#+END_EXAMPLE

6. Use that bitcoin to purchase one of the API calls listed above (eg translation)

#+BEGIN_EXAMPLE
# Purchase from vendor with best price, max 500 Satoshis per call
# Echo the underlying HTTP GET under the hood, using the requests library
$ two1 buy en2cn --stdin {"text": "What is your name?"}
                 --bitin $BITCOIN/wallet.dat
                 --sortby price
                 --max 5000
$ two1 buy en2cn --sortby rating [other options as above] # purchase from vendor with best rating
$ two1 buy foo.com/en2cn                  # buy specifically from a specified vendor
#+END_EXAMPLE

7. Another one (cross compilation to ARM - compare to doing this locally)

# Note the use of {} to set up the template for a local file to serve as
# input. Two1 will expand that, construct the full command line, and then
# echo it (and/or do an HTTP POST with the Python requests library)
#+BEGIN_EXAMPLE
$ two1 buy compile --best price
                   --data data.zip            # data for POST
                   --stdin {"arch": "arm64"}  # arguments
                   --bitin $BITCOIN/wallet.dat
                   --max 5000
                   > foo.o
#+END_EXAMPLE

8. And another purchase (wget an image and then recognize it or do
   something cool). Echo the input and output.

#+BEGIN_EXAMPLE
$ wget example.com/team-photo.png
$ two1 buy face-recognition --data team-photo.png \
                            --stdin {"file": "{data.file}"} \
                            --bitin $BITCOIN/wallet.dat \
                            --max 5000 \
                            > image-tagged.png
#+END_EXAMPLE

9. Now do a basic Satoshi Dice-like gambling game. Command line Satoshi Dice.

#+BEGIN_EXAMPLE
$ two1 buy satoshi-dice --bitin $BITCOIN/wallet.dat
                        --amt 21000
                        --bitout $BITCOIN/wallet2.dat
#+END_EXAMPLE

10. Run stats again to see what you've spent to date and how much you
    have. With the --private, shows private keys as well.

#+BEGIN_EXAMPLE
$ two1 status
$ two1 status --private
#+END_EXAMPLE

10. Rate the guy you just bought from:

#+BEGIN_EXAMPLE
$ two1 rate --endpoint foo.com/en2cn --rating 4.3
[timestamp] username rated foo.com/en2cn by vendor a rating of 4.3
#+END_EXAMPLE

11. Now sell something (do help first)

#+BEGIN_EXAMPLE
$ two1 sell --help
#+END_EXAMPLE

12. See what is available to sell: built-in (from 21), 3rd party, and your own stuff

#+BEGIN_EXAMPLE
$ two1 sell --builtin
#+END_EXAMPLE

13. Choose something to sell and make it go live (uses zerotier behind the scenes)

#+BEGIN_EXAMPLE
  # First step may require sudo. Behind the scenes, we need to start zerotier (perhaps upon boot?)
  # and have the RPi join our private network. Then the RPi is curlable from anywhere else on the private network - and, if we can set it up right, via 
  # a mmm.21.co username also on the internet itself (eg mmm.21.co/username/$endpoint). We use mmm.21.co rather than 21.co as we want to popularize the MMM concept.
  #
  # Next step: make sure there is a bot that is listening for new things on the MMM and will spend something 
  # as a sort of "welcome to the MMM" kind of bot, to confirm.
#+END_EXAMPLE

Now we have a routable IP address.

#+BEGIN_EXAMPLE
$ two1 sell two1.en2cn
[timestamp]  Server is running, listening at IP:port
[timestamp]  Selling the en2cn endpoint for X Satoshis
[timestamp]  TEST request received from test.21.co! Sold 1 request(s) for 1000 Satoshis
[timestamp]  Publishing mydomain.com/en2cn on the MMM
[timestamp]  Request received from ___! Sold 10 request(s) for 10000 Satoshis
[timestamp]  Request received from ___! Sold 4 request(s) for 4000 Satoshis
[timestamp]  Request received from ___! Sold 19 request(s) for 19000 Satoshis

$ two1 status --endpoints
| URL               |        IP | Port | Price | Name       | MMM? | Description        | # Requests | Satoshis Received | USD equivalent |
|-------------------+-----------+------+-------+------------+------+--------------------+------------+-------------------+----------------|
| example.com/en2cn | 127.0.0.1 | 8000 |  1000 | two1.en2cn | No   | English to Chinese |         27 |             27000 | $0.08          |
| example.com/en2es | 127.0.0.1 | 8000 |  2000 | two1.en2es | No   | English to Spanish |         33 |             33000 | $0.099         |

$ two1 sell two1.facerecognition
#+END_EXAMPLE

14. Run a test to make sure it's actually working (i.e. receive some
    bitcoin from 21.co)

#+BEGIN_EXAMPLE
$ two1 sell two1.en2cn --test
  # Starts this endpoint if not already running. If it is running, pings the 21.co servers and 
  # sends some bitcoin to make sure it's working.
#+END_EXAMPLE

Important point: just like two1 mine is running in the background.

15. Again, check your endpoints to see the stats and the bitcoin received

#+BEGIN_EXAMPLE
$ two1 status
  # see above for output
#+END_EXAMPLE

16. Do it again for a 3rd party piece of code. 

#+BEGIN_EXAMPLE
# Now we use a package that is not bundled with two1, but that comes from github. 
# We'll need a very simple format - basically a python function in a file should do, with some syntax for STDIN, BITIN, STDOUT, STDERR, BITOUT

$ git clone github.com/foo/bitcoinemail.git # or otherwise install this locally
$ two1 sell foo.bitcoinemail --email balajis@21.co --price 100000 # email me for 100k Satoshis; email is not disclosed
#+END_EXAMPLE

17. Again run a test and see that it's actually working and that the
    bitcoin is received.

#+BEGIN_EXAMPLE
$ two1 sell foo.bitcoinemail --test
#+END_EXAMPLE

18. Now search the Many Machine Market for what you want to sell. Decide on
    the price point by looking at the other things. Let's say that we want
    to sell slightly below others.

#+BEGIN_EXAMPLE
$ two1 search translation

# List a bunch of endpoints that satisfy this keyword search
# We can use a simple JSON datastructure in memory to mock this up. 
# The real thing is going to be a database query to the 21.co index servers.
#+END_EXAMPLE

19. Hit publish and get feedback (via ANSI color strings in the terminal?)
    to see which of your URL endpoints are local and which are live on the
    MMM

#+BEGIN_EXAMPLE
$ two1 publish two1.en2cn
[timestamp] You are now publishing example.com/en2cn on the MMM!
[timestamp] Your public API URL is mmm.21.co/username/en2cn
#+END_EXAMPLE

20. Show some configuration variables
    - default username
    - default price
    - default vendor contact for MMM
    - default naming (lowercase and hyphenate)
    - default stdout directory (if not specified)
    - default stderr directory (if not specified)
    - default bitin directory (if not specified - bitcoin from /dev/bitcoin)
    - default bitout directory (if not specified - bitcoin returned by
      server, eg via Satoshi Dice)
    - default vendor ranking (price, stars)
    - max amount to spend on one API call, in Satoshis (5000)
    - verbosity (do we echo the exact sequence of endpoints contacted and
      ther result or not)

#+BEGIN_EXAMPLE
$ two1 config
  username   : balajis
  contact    : balajis@21.co
  stdin      : STDIN
  stdout     : .two1/two1.log
  stderr     : .two1/two1.log
  bitin      : .two1/wallet.dat
  bitout     : .two1/wallet.dat
  sortby     : rating
  maxbuy     : 1000 Satoshis
  minsell    : 1000 Satoshis
  verbose    : True
#+END_EXAMPLE

* Feature notes

Status
  - include deviceID, IP address, and username in status
  - include zerotier admin interface scripts: https://github.com/Red5d/ztadmin
  - list source of earned bitcoin
  - review the Click app
  - have a fake wallet which has addresses
  - include videogame-like revenue sources which you can attach (earners)
    that you can refresh with status



Market
  - digital goods organized by category
  - for each digital good
    - buyers
    - sellers
    - market tickers
  - the market server pings each known endpoint say every N seconds to get
    the latest information and generates a ticker


Buyer Endpoint (Tender Offer)
  - URL of endpoint
  - per-request amount being bought
  - formatter to confirm that the input is to specifications (basically a validator/parser)
  - total amount on offer
  - other fields similar to Seller


Seller Endpoint
  - URL of endpoint
  - price-per-request in Satoshis (or more sophisticated pricing function)
  - description (text)
  - automatically extracted keywords
  - vendor email
  - reviews of the endpoint by other users (timestamp, star rating, user
    email) + aggregate review
  - balance received (only known by those with login)
  - supply (in requests-per-second, say)

Key questions
  - Can we actually get a price ticker? We can only get a ticker if supply
    is limited. In this case, supply is limited only if the rate is limited
    (eg file conversion or compilation, which takes a few
    minutes). Obviously every service has finite capacity. If it returns a
    busy signal then everyone else's price can dynamically increase.
  - For illustrative purposes, we can use sleep to set an artificial
    requests-per-second threshold. If you want 1 RPS, you pay X; if you
    want 4 RPS, you pay X+Y; if you want 10 RPS, you pay X+Y+Z to send it
    to a bunch of servers.
  - For parallel jobs things get interesting. You could break up text and
    factor it among servers.
  - What is the best command line wallet right now
  - What is the status on all individual tasks
  - Can we get a basic Satoshi Dice working between two 21 Bitcoin Nodes
  - Can we get a blockchain confirmation going between two 21 Bitcoin Nodes
  - How much text can we get done
  - Can we get a big map/reduce out tonight w/ Andy
  - Can we write the 1/1 documentation tonight w/ Andy
  - Clean out the queue?
  - For searching MMM later: https://www.algolia.com/

Data analysis
  - Any moderately large repo would be an interesting database to analyze
