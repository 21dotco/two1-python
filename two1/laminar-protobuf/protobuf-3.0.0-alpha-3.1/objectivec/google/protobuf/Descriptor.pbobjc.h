// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/protobuf/descriptor.proto

#import "GPBProtocolBuffers.h"

#if GOOGLE_PROTOBUF_OBJC_GEN_VERSION != 30000
#error This file was generated by a different version of protoc-gen-objc which is incompatible with your Protocol Buffer sources.
#endif

// @@protoc_insertion_point(imports)

CF_EXTERN_C_BEGIN

@class GPBEnumOptions;
@class GPBEnumValueOptions;
@class GPBFieldOptions;
@class GPBFileOptions;
@class GPBMessageOptions;
@class GPBMethodOptions;
@class GPBServiceOptions;
@class GPBSourceCodeInfo;

#pragma mark - Enum GPBFieldDescriptorProto_Type

typedef GPB_ENUM(GPBFieldDescriptorProto_Type) {
  // 0 is reserved for errors.
  // Order is weird for historical reasons.
  GPBFieldDescriptorProto_Type_TypeDouble = 1,
  GPBFieldDescriptorProto_Type_TypeFloat = 2,

  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
  // negative values are likely.
  GPBFieldDescriptorProto_Type_TypeInt64 = 3,
  GPBFieldDescriptorProto_Type_TypeUint64 = 4,

  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
  // negative values are likely.
  GPBFieldDescriptorProto_Type_TypeInt32 = 5,
  GPBFieldDescriptorProto_Type_TypeFixed64 = 6,
  GPBFieldDescriptorProto_Type_TypeFixed32 = 7,
  GPBFieldDescriptorProto_Type_TypeBool = 8,
  GPBFieldDescriptorProto_Type_TypeString = 9,

  // Tag-delimited aggregate.
  GPBFieldDescriptorProto_Type_TypeGroup = 10,

  // Length-delimited aggregate.
  GPBFieldDescriptorProto_Type_TypeMessage = 11,

  // New in version 2.
  GPBFieldDescriptorProto_Type_TypeBytes = 12,
  GPBFieldDescriptorProto_Type_TypeUint32 = 13,
  GPBFieldDescriptorProto_Type_TypeEnum = 14,
  GPBFieldDescriptorProto_Type_TypeSfixed32 = 15,
  GPBFieldDescriptorProto_Type_TypeSfixed64 = 16,

  // Uses ZigZag encoding.
  GPBFieldDescriptorProto_Type_TypeSint32 = 17,

  // Uses ZigZag encoding.
  GPBFieldDescriptorProto_Type_TypeSint64 = 18,
};

GPBEnumDescriptor *GPBFieldDescriptorProto_Type_EnumDescriptor(void);

BOOL GPBFieldDescriptorProto_Type_IsValidValue(int32_t value);

#pragma mark - Enum GPBFieldDescriptorProto_Label

typedef GPB_ENUM(GPBFieldDescriptorProto_Label) {
  // 0 is reserved for errors
  GPBFieldDescriptorProto_Label_LabelOptional = 1,
  GPBFieldDescriptorProto_Label_LabelRequired = 2,

  // TODO(sanjay): Should we add LABEL_MAP?
  GPBFieldDescriptorProto_Label_LabelRepeated = 3,
};

GPBEnumDescriptor *GPBFieldDescriptorProto_Label_EnumDescriptor(void);

BOOL GPBFieldDescriptorProto_Label_IsValidValue(int32_t value);

#pragma mark - Enum GPBFileOptions_OptimizeMode

// Generated classes can be optimized for speed or code size.
typedef GPB_ENUM(GPBFileOptions_OptimizeMode) {
  // Generate complete code for parsing, serialization,
  GPBFileOptions_OptimizeMode_Speed = 1,

  // etc.
  GPBFileOptions_OptimizeMode_CodeSize = 2,

  // Generate code using MessageLite and the lite runtime.
  GPBFileOptions_OptimizeMode_LiteRuntime = 3,
};

GPBEnumDescriptor *GPBFileOptions_OptimizeMode_EnumDescriptor(void);

BOOL GPBFileOptions_OptimizeMode_IsValidValue(int32_t value);

#pragma mark - Enum GPBFieldOptions_CType

typedef GPB_ENUM(GPBFieldOptions_CType) {
  // Default mode.
  GPBFieldOptions_CType_String = 0,
  GPBFieldOptions_CType_Cord = 1,
  GPBFieldOptions_CType_StringPiece = 2,
};

GPBEnumDescriptor *GPBFieldOptions_CType_EnumDescriptor(void);

BOOL GPBFieldOptions_CType_IsValidValue(int32_t value);

#pragma mark - Enum GPBFieldOptions_JSType

typedef GPB_ENUM(GPBFieldOptions_JSType) {
  // Use the default type.
  GPBFieldOptions_JSType_JsNormal = 0,

  // Use JavaScript strings.
  GPBFieldOptions_JSType_JsString = 1,

  // Use JavaScript numbers.
  GPBFieldOptions_JSType_JsNumber = 2,
};

GPBEnumDescriptor *GPBFieldOptions_JSType_EnumDescriptor(void);

BOOL GPBFieldOptions_JSType_IsValidValue(int32_t value);


#pragma mark - GPBDescriptorRoot

@interface GPBDescriptorRoot : GPBRootObject

// The base class provides:
//   + (GPBExtensionRegistry *)extensionRegistry;
// which is an GPBExtensionRegistry that includes all the extensions defined by
// this file and all files that it depends on.

@end

#pragma mark - GPBFileDescriptorSet

typedef GPB_ENUM(GPBFileDescriptorSet_FieldNumber) {
  GPBFileDescriptorSet_FieldNumber_FileArray = 1,
};

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
@interface GPBFileDescriptorSet : GPBMessage

// |fileArray| contains |GPBFileDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *fileArray;

@end

#pragma mark - GPBFileDescriptorProto

typedef GPB_ENUM(GPBFileDescriptorProto_FieldNumber) {
  GPBFileDescriptorProto_FieldNumber_Name = 1,
  GPBFileDescriptorProto_FieldNumber_Package = 2,
  GPBFileDescriptorProto_FieldNumber_DependencyArray = 3,
  GPBFileDescriptorProto_FieldNumber_MessageTypeArray = 4,
  GPBFileDescriptorProto_FieldNumber_EnumTypeArray = 5,
  GPBFileDescriptorProto_FieldNumber_ServiceArray = 6,
  GPBFileDescriptorProto_FieldNumber_ExtensionArray = 7,
  GPBFileDescriptorProto_FieldNumber_Options = 8,
  GPBFileDescriptorProto_FieldNumber_SourceCodeInfo = 9,
  GPBFileDescriptorProto_FieldNumber_PublicDependencyArray = 10,
  GPBFileDescriptorProto_FieldNumber_WeakDependencyArray = 11,
  GPBFileDescriptorProto_FieldNumber_Syntax = 12,
};

// Describes a complete .proto file.
@interface GPBFileDescriptorProto : GPBMessage

// file name, relative to root of source tree
@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

// e.g. "foo", "foo.bar", etc.
@property(nonatomic, readwrite) BOOL hasPackage;
@property(nonatomic, readwrite, copy) NSString *package;

// Names of files imported by this file.
// |dependencyArray| contains |NSString|
@property(nonatomic, readwrite, strong) NSMutableArray *dependencyArray;

// Indexes of the public imported files in the dependency list above.
@property(nonatomic, readwrite, strong) GPBInt32Array *publicDependencyArray;

// Indexes of the weak imported files in the dependency list.
// For Google-internal migration only. Do not use.
@property(nonatomic, readwrite, strong) GPBInt32Array *weakDependencyArray;

// All top-level definitions in this file.
// |messageTypeArray| contains |GPBDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *messageTypeArray;

// |enumTypeArray| contains |GPBEnumDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *enumTypeArray;

// |serviceArray| contains |GPBServiceDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *serviceArray;

// |extensionArray| contains |GPBFieldDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *extensionArray;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBFileOptions *options;

// This field contains optional information about the original source code.
// You may safely remove this entire field without harming runtime
// functionality of the descriptors -- the information is needed only by
// development tools.
@property(nonatomic, readwrite) BOOL hasSourceCodeInfo;
@property(nonatomic, readwrite, strong) GPBSourceCodeInfo *sourceCodeInfo;

// The syntax of the proto file.
// The supported values are "proto2" and "proto3".
@property(nonatomic, readwrite) BOOL hasSyntax;
@property(nonatomic, readwrite, copy) NSString *syntax;

@end

#pragma mark - GPBDescriptorProto

typedef GPB_ENUM(GPBDescriptorProto_FieldNumber) {
  GPBDescriptorProto_FieldNumber_Name = 1,
  GPBDescriptorProto_FieldNumber_FieldArray = 2,
  GPBDescriptorProto_FieldNumber_NestedTypeArray = 3,
  GPBDescriptorProto_FieldNumber_EnumTypeArray = 4,
  GPBDescriptorProto_FieldNumber_ExtensionRangeArray = 5,
  GPBDescriptorProto_FieldNumber_ExtensionArray = 6,
  GPBDescriptorProto_FieldNumber_Options = 7,
  GPBDescriptorProto_FieldNumber_OneofDeclArray = 8,
  GPBDescriptorProto_FieldNumber_ReservedRangeArray = 9,
  GPBDescriptorProto_FieldNumber_ReservedNameArray = 10,
};

// Describes a message type.
@interface GPBDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

// |fieldArray| contains |GPBFieldDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *fieldArray;

// |extensionArray| contains |GPBFieldDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *extensionArray;

// |nestedTypeArray| contains |GPBDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *nestedTypeArray;

// |enumTypeArray| contains |GPBEnumDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *enumTypeArray;

// |extensionRangeArray| contains |GPBDescriptorProto_ExtensionRange|
@property(nonatomic, readwrite, strong) NSMutableArray *extensionRangeArray;

// |oneofDeclArray| contains |GPBOneofDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *oneofDeclArray;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBMessageOptions *options;

// |reservedRangeArray| contains |GPBDescriptorProto_ReservedRange|
@property(nonatomic, readwrite, strong) NSMutableArray *reservedRangeArray;

// Reserved field names, which may not be used by fields in the same message.
// A given name may only be reserved once.
// |reservedNameArray| contains |NSString|
@property(nonatomic, readwrite, strong) NSMutableArray *reservedNameArray;

@end

#pragma mark - GPBDescriptorProto_ExtensionRange

typedef GPB_ENUM(GPBDescriptorProto_ExtensionRange_FieldNumber) {
  GPBDescriptorProto_ExtensionRange_FieldNumber_Start = 1,
  GPBDescriptorProto_ExtensionRange_FieldNumber_End = 2,
};

@interface GPBDescriptorProto_ExtensionRange : GPBMessage

@property(nonatomic, readwrite) BOOL hasStart;
@property(nonatomic, readwrite) int32_t start;

@property(nonatomic, readwrite) BOOL hasEnd;
@property(nonatomic, readwrite) int32_t end;

@end

#pragma mark - GPBDescriptorProto_ReservedRange

typedef GPB_ENUM(GPBDescriptorProto_ReservedRange_FieldNumber) {
  GPBDescriptorProto_ReservedRange_FieldNumber_Start = 1,
  GPBDescriptorProto_ReservedRange_FieldNumber_End = 2,
};

// Range of reserved tag numbers. Reserved tag numbers may not be used by
// fields or extension ranges in the same message. Reserved ranges may
// not overlap.
@interface GPBDescriptorProto_ReservedRange : GPBMessage

// Inclusive.
@property(nonatomic, readwrite) BOOL hasStart;
@property(nonatomic, readwrite) int32_t start;

// Exclusive.
@property(nonatomic, readwrite) BOOL hasEnd;
@property(nonatomic, readwrite) int32_t end;

@end

#pragma mark - GPBFieldDescriptorProto

typedef GPB_ENUM(GPBFieldDescriptorProto_FieldNumber) {
  GPBFieldDescriptorProto_FieldNumber_Name = 1,
  GPBFieldDescriptorProto_FieldNumber_Extendee = 2,
  GPBFieldDescriptorProto_FieldNumber_Number = 3,
  GPBFieldDescriptorProto_FieldNumber_Label = 4,
  GPBFieldDescriptorProto_FieldNumber_Type = 5,
  GPBFieldDescriptorProto_FieldNumber_TypeName = 6,
  GPBFieldDescriptorProto_FieldNumber_DefaultValue = 7,
  GPBFieldDescriptorProto_FieldNumber_Options = 8,
  GPBFieldDescriptorProto_FieldNumber_OneofIndex = 9,
};

// Describes a field within a message.
@interface GPBFieldDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

@property(nonatomic, readwrite) BOOL hasNumber;
@property(nonatomic, readwrite) int32_t number;

@property(nonatomic, readwrite) BOOL hasLabel;
@property(nonatomic, readwrite) GPBFieldDescriptorProto_Label label;

// If type_name is set, this need not be set.  If both this and type_name
// are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
@property(nonatomic, readwrite) BOOL hasType;
@property(nonatomic, readwrite) GPBFieldDescriptorProto_Type type;

// For message and enum types, this is the name of the type.  If the name
// starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
// rules are used to find the type (i.e. first the nested types within this
// message are searched, then within the parent, on up to the root
// namespace).
@property(nonatomic, readwrite) BOOL hasTypeName;
@property(nonatomic, readwrite, copy) NSString *typeName;

// For extensions, this is the name of the type being extended.  It is
// resolved in the same manner as type_name.
@property(nonatomic, readwrite) BOOL hasExtendee;
@property(nonatomic, readwrite, copy) NSString *extendee;

// For numeric types, contains the original text representation of the value.
// For booleans, "true" or "false".
// For strings, contains the default text contents (not escaped in any way).
// For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
// TODO(kenton):  Base-64 encode?
@property(nonatomic, readwrite) BOOL hasDefaultValue;
@property(nonatomic, readwrite, copy) NSString *defaultValue;

// If set, gives the index of a oneof in the containing type's oneof_decl
// list.  This field is a member of that oneof.
@property(nonatomic, readwrite) BOOL hasOneofIndex;
@property(nonatomic, readwrite) int32_t oneofIndex;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBFieldOptions *options;

@end

#pragma mark - GPBOneofDescriptorProto

typedef GPB_ENUM(GPBOneofDescriptorProto_FieldNumber) {
  GPBOneofDescriptorProto_FieldNumber_Name = 1,
};

// Describes a oneof.
@interface GPBOneofDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

@end

#pragma mark - GPBEnumDescriptorProto

typedef GPB_ENUM(GPBEnumDescriptorProto_FieldNumber) {
  GPBEnumDescriptorProto_FieldNumber_Name = 1,
  GPBEnumDescriptorProto_FieldNumber_ValueArray = 2,
  GPBEnumDescriptorProto_FieldNumber_Options = 3,
};

// Describes an enum type.
@interface GPBEnumDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

// |valueArray| contains |GPBEnumValueDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *valueArray;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBEnumOptions *options;

@end

#pragma mark - GPBEnumValueDescriptorProto

typedef GPB_ENUM(GPBEnumValueDescriptorProto_FieldNumber) {
  GPBEnumValueDescriptorProto_FieldNumber_Name = 1,
  GPBEnumValueDescriptorProto_FieldNumber_Number = 2,
  GPBEnumValueDescriptorProto_FieldNumber_Options = 3,
};

// Describes a value within an enum.
@interface GPBEnumValueDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

@property(nonatomic, readwrite) BOOL hasNumber;
@property(nonatomic, readwrite) int32_t number;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBEnumValueOptions *options;

@end

#pragma mark - GPBServiceDescriptorProto

typedef GPB_ENUM(GPBServiceDescriptorProto_FieldNumber) {
  GPBServiceDescriptorProto_FieldNumber_Name = 1,
  GPBServiceDescriptorProto_FieldNumber_MethodArray = 2,
  GPBServiceDescriptorProto_FieldNumber_Options = 3,
};

// Describes a service.
@interface GPBServiceDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

// |methodArray| contains |GPBMethodDescriptorProto|
@property(nonatomic, readwrite, strong) NSMutableArray *methodArray;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBServiceOptions *options;

@end

#pragma mark - GPBMethodDescriptorProto

typedef GPB_ENUM(GPBMethodDescriptorProto_FieldNumber) {
  GPBMethodDescriptorProto_FieldNumber_Name = 1,
  GPBMethodDescriptorProto_FieldNumber_InputType = 2,
  GPBMethodDescriptorProto_FieldNumber_OutputType = 3,
  GPBMethodDescriptorProto_FieldNumber_Options = 4,
  GPBMethodDescriptorProto_FieldNumber_ClientStreaming = 5,
  GPBMethodDescriptorProto_FieldNumber_ServerStreaming = 6,
};

// Describes a method of a service.
@interface GPBMethodDescriptorProto : GPBMessage

@property(nonatomic, readwrite) BOOL hasName;
@property(nonatomic, readwrite, copy) NSString *name;

// Input and output type names.  These are resolved in the same way as
// FieldDescriptorProto.type_name, but must refer to a message type.
@property(nonatomic, readwrite) BOOL hasInputType;
@property(nonatomic, readwrite, copy) NSString *inputType;

@property(nonatomic, readwrite) BOOL hasOutputType;
@property(nonatomic, readwrite, copy) NSString *outputType;

@property(nonatomic, readwrite) BOOL hasOptions;
@property(nonatomic, readwrite, strong) GPBMethodOptions *options;

// Identifies if client streams multiple client messages
@property(nonatomic, readwrite) BOOL hasClientStreaming;
@property(nonatomic, readwrite) BOOL clientStreaming;

// Identifies if server streams multiple server messages
@property(nonatomic, readwrite) BOOL hasServerStreaming;
@property(nonatomic, readwrite) BOOL serverStreaming;

@end

#pragma mark - GPBFileOptions

typedef GPB_ENUM(GPBFileOptions_FieldNumber) {
  GPBFileOptions_FieldNumber_JavaPackage = 1,
  GPBFileOptions_FieldNumber_JavaOuterClassname = 8,
  GPBFileOptions_FieldNumber_OptimizeFor = 9,
  GPBFileOptions_FieldNumber_JavaMultipleFiles = 10,
  GPBFileOptions_FieldNumber_GoPackage = 11,
  GPBFileOptions_FieldNumber_CcGenericServices = 16,
  GPBFileOptions_FieldNumber_JavaGenericServices = 17,
  GPBFileOptions_FieldNumber_PyGenericServices = 18,
  GPBFileOptions_FieldNumber_JavaGenerateEqualsAndHash = 20,
  GPBFileOptions_FieldNumber_Deprecated = 23,
  GPBFileOptions_FieldNumber_JavaStringCheckUtf8 = 27,
  GPBFileOptions_FieldNumber_CcEnableArenas = 31,
  GPBFileOptions_FieldNumber_ObjcClassPrefix = 36,
  GPBFileOptions_FieldNumber_CsharpNamespace = 37,
  GPBFileOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBFileOptions : GPBMessage

// Sets the Java package where classes generated from this .proto will be
// placed.  By default, the proto package is used, but this is often
// inappropriate because proto packages do not normally start with backwards
// domain names.
@property(nonatomic, readwrite) BOOL hasJavaPackage;
@property(nonatomic, readwrite, copy) NSString *javaPackage;

// If set, all the classes from the .proto file are wrapped in a single
// outer class with the given name.  This applies to both Proto1
// (equivalent to the old "--one_java_file" option) and Proto2 (where
// a .proto always translates to a single class, but you may want to
// explicitly choose the class name).
@property(nonatomic, readwrite) BOOL hasJavaOuterClassname;
@property(nonatomic, readwrite, copy) NSString *javaOuterClassname;

// If set true, then the Java code generator will generate a separate .java
// file for each top-level message, enum, and service defined in the .proto
// file.  Thus, these types will *not* be nested inside the outer class
// named by java_outer_classname.  However, the outer class will still be
// generated to contain the file's getDescriptor() method as well as any
// top-level extensions defined in the file.
@property(nonatomic, readwrite) BOOL hasJavaMultipleFiles;
@property(nonatomic, readwrite) BOOL javaMultipleFiles;

// If set true, then the Java code generator will generate equals() and
// hashCode() methods for all messages defined in the .proto file.
// - In the full runtime, this is purely a speed optimization, as the
// AbstractMessage base class includes reflection-based implementations of
// these methods.
//- In the lite runtime, setting this option changes the semantics of
// equals() and hashCode() to more closely match those of the full runtime;
// the generated methods compute their results based on field values rather
// than object identity. (Implementations should not assume that hashcodes
// will be consistent across runtimes or versions of the protocol compiler.)
@property(nonatomic, readwrite) BOOL hasJavaGenerateEqualsAndHash;
@property(nonatomic, readwrite) BOOL javaGenerateEqualsAndHash;

// If set true, then the Java2 code generator will generate code that
// throws an exception whenever an attempt is made to assign a non-UTF-8
// byte sequence to a string field.
// Message reflection will do the same.
// However, an extension field still accepts non-UTF-8 byte sequences.
// This option has no effect on when used with the lite runtime.
@property(nonatomic, readwrite) BOOL hasJavaStringCheckUtf8;
@property(nonatomic, readwrite) BOOL javaStringCheckUtf8;

@property(nonatomic, readwrite) BOOL hasOptimizeFor;
@property(nonatomic, readwrite) GPBFileOptions_OptimizeMode optimizeFor;

// Sets the Go package where structs generated from this .proto will be
// placed. If omitted, the Go package will be derived from the following:
//   - The basename of the package import path, if provided.
//   - Otherwise, the package statement in the .proto file, if present.
//   - Otherwise, the basename of the .proto file, without extension.
@property(nonatomic, readwrite) BOOL hasGoPackage;
@property(nonatomic, readwrite, copy) NSString *goPackage;

// Should generic services be generated in each language?  "Generic" services
// are not specific to any particular RPC system.  They are generated by the
// main code generators in each language (without additional plugins).
// Generic services were the only kind of service generation supported by
// early versions of google.protobuf.
//
// Generic services are now considered deprecated in favor of using plugins
// that generate code specific to your particular RPC system.  Therefore,
// these default to false.  Old code which depends on generic services should
// explicitly set them to true.
@property(nonatomic, readwrite) BOOL hasCcGenericServices;
@property(nonatomic, readwrite) BOOL ccGenericServices;

@property(nonatomic, readwrite) BOOL hasJavaGenericServices;
@property(nonatomic, readwrite) BOOL javaGenericServices;

@property(nonatomic, readwrite) BOOL hasPyGenericServices;
@property(nonatomic, readwrite) BOOL pyGenericServices;

// Is this file deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for everything in the file, or it will be completely ignored; in the very
// least, this is a formalization for deprecating files.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// Enables the use of arenas for the proto messages in this file. This applies
// only to generated classes for C++.
@property(nonatomic, readwrite) BOOL hasCcEnableArenas;
@property(nonatomic, readwrite) BOOL ccEnableArenas;

// Sets the objective c class prefix which is prepended to all objective c
// generated classes from this .proto. There is no default.
@property(nonatomic, readwrite) BOOL hasObjcClassPrefix;
@property(nonatomic, readwrite, copy) NSString *objcClassPrefix;

// Namespace for generated classes; defaults to the package.
@property(nonatomic, readwrite) BOOL hasCsharpNamespace;
@property(nonatomic, readwrite, copy) NSString *csharpNamespace;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBMessageOptions

typedef GPB_ENUM(GPBMessageOptions_FieldNumber) {
  GPBMessageOptions_FieldNumber_MessageSetWireFormat = 1,
  GPBMessageOptions_FieldNumber_NoStandardDescriptorAccessor = 2,
  GPBMessageOptions_FieldNumber_Deprecated = 3,
  GPBMessageOptions_FieldNumber_MapEntry = 7,
  GPBMessageOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBMessageOptions : GPBMessage

// Set true to use the old proto1 MessageSet wire format for extensions.
// This is provided for backwards-compatibility with the MessageSet wire
// format.  You should not use this for any other reason:  It's less
// efficient, has fewer features, and is more complicated.
//
// The message must be defined exactly as follows:
//   message Foo {
//     option message_set_wire_format = true;
//     extensions 4 to max;
//   }
// Note that the message cannot have any defined fields; MessageSets only
// have extensions.
//
// All extensions of your type must be singular messages; e.g. they cannot
// be int32s, enums, or repeated messages.
//
// Because this is an option, the above two restrictions are not enforced by
// the protocol compiler.
@property(nonatomic, readwrite) BOOL hasMessageSetWireFormat;
@property(nonatomic, readwrite) BOOL messageSetWireFormat;

// Disables the generation of the standard "descriptor()" accessor, which can
// conflict with a field of the same name.  This is meant to make migration
// from proto1 easier; new code should avoid fields named "descriptor".
@property(nonatomic, readwrite) BOOL hasNoStandardDescriptorAccessor;
@property(nonatomic, readwrite) BOOL noStandardDescriptorAccessor;

// Is this message deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the message, or it will be completely ignored; in the very least,
// this is a formalization for deprecating messages.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// Whether the message is an automatically generated map entry type for the
// maps field.
//
// For maps fields:
//     map<KeyType, ValueType> map_field = 1;
// The parsed descriptor looks like:
//     message MapFieldEntry {
//         option map_entry = true;
//         optional KeyType key = 1;
//         optional ValueType value = 2;
//     }
//     repeated MapFieldEntry map_field = 1;
//
// Implementations may choose not to generate the map_entry=true message, but
// use a native map in the target language to hold the keys and values.
// The reflection APIs in such implementions still need to work as
// if the field is a repeated message field.
//
// NOTE: Do not set the option in .proto files. Always use the maps syntax
// instead. The option should only be implicitly set by the proto compiler
// parser.
@property(nonatomic, readwrite) BOOL hasMapEntry;
@property(nonatomic, readwrite) BOOL mapEntry;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBFieldOptions

typedef GPB_ENUM(GPBFieldOptions_FieldNumber) {
  GPBFieldOptions_FieldNumber_Ctype = 1,
  GPBFieldOptions_FieldNumber_Packed = 2,
  GPBFieldOptions_FieldNumber_Deprecated = 3,
  GPBFieldOptions_FieldNumber_Lazy = 5,
  GPBFieldOptions_FieldNumber_Jstype = 6,
  GPBFieldOptions_FieldNumber_Weak = 10,
  GPBFieldOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBFieldOptions : GPBMessage

// The ctype option instructs the C++ code generator to use a different
// representation of the field than it normally would.  See the specific
// options below.  This option is not yet implemented in the open source
// release -- sorry, we'll try to include it in a future version!
@property(nonatomic, readwrite) BOOL hasCtype;
@property(nonatomic, readwrite) GPBFieldOptions_CType ctype;

// The packed option can be enabled for repeated primitive fields to enable
// a more efficient representation on the wire. Rather than repeatedly
// writing the tag and type for each element, the entire array is encoded as
// a single length-delimited blob. In proto3, only explicit setting it to
// false will avoid using packed encoding.
@property(nonatomic, readwrite) BOOL hasPacked;
@property(nonatomic, readwrite) BOOL packed;

// The jstype option determines the JavaScript type used for values of the
// field.  The option is permitted only for 64 bit integral and fixed types
// (int64, uint64, sint64, fixed64, sfixed64).  By default these types are
// represented as JavaScript strings.  This avoids loss of precision that can
// happen when a large value is converted to a floating point JavaScript
// numbers.  Specifying JS_NUMBER for the jstype causes the generated
// JavaScript code to use the JavaScript "number" type instead of strings.
// This option is an enum to permit additional types to be added,
// e.g. goog.math.Integer.
@property(nonatomic, readwrite) BOOL hasJstype;
@property(nonatomic, readwrite) GPBFieldOptions_JSType jstype;

// Should this field be parsed lazily?  Lazy applies only to message-type
// fields.  It means that when the outer message is initially parsed, the
// inner message's contents will not be parsed but instead stored in encoded
// form.  The inner message will actually be parsed when it is first accessed.
//
// This is only a hint.  Implementations are free to choose whether to use
// eager or lazy parsing regardless of the value of this option.  However,
// setting this option true suggests that the protocol author believes that
// using lazy parsing on this field is worth the additional bookkeeping
// overhead typically needed to implement it.
//
// This option does not affect the public interface of any generated code;
// all method signatures remain the same.  Furthermore, thread-safety of the
// interface is not affected by this option; const methods remain safe to
// call from multiple threads concurrently, while non-const methods continue
// to require exclusive access.
//
//
// Note that implementations may choose not to check required fields within
// a lazy sub-message.  That is, calling IsInitialized() on the outher message
// may return true even if the inner message has missing required fields.
// This is necessary because otherwise the inner message would have to be
// parsed in order to perform the check, defeating the purpose of lazy
// parsing.  An implementation which chooses not to check required fields
// must be consistent about it.  That is, for any particular sub-message, the
// implementation must either *always* check its required fields, or *never*
// check its required fields, regardless of whether or not the message has
// been parsed.
@property(nonatomic, readwrite) BOOL hasLazy;
@property(nonatomic, readwrite) BOOL lazy;

// Is this field deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for accessors, or it will be completely ignored; in the very least, this
// is a formalization for deprecating fields.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// For Google-internal migration only. Do not use.
@property(nonatomic, readwrite) BOOL hasWeak;
@property(nonatomic, readwrite) BOOL weak;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBEnumOptions

typedef GPB_ENUM(GPBEnumOptions_FieldNumber) {
  GPBEnumOptions_FieldNumber_AllowAlias = 2,
  GPBEnumOptions_FieldNumber_Deprecated = 3,
  GPBEnumOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBEnumOptions : GPBMessage

// Set this option to true to allow mapping different tag names to the same
// value.
@property(nonatomic, readwrite) BOOL hasAllowAlias;
@property(nonatomic, readwrite) BOOL allowAlias;

// Is this enum deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the enum, or it will be completely ignored; in the very least, this
// is a formalization for deprecating enums.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBEnumValueOptions

typedef GPB_ENUM(GPBEnumValueOptions_FieldNumber) {
  GPBEnumValueOptions_FieldNumber_Deprecated = 1,
  GPBEnumValueOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBEnumValueOptions : GPBMessage

// Is this enum value deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the enum value, or it will be completely ignored; in the very least,
// this is a formalization for deprecating enum values.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBServiceOptions

typedef GPB_ENUM(GPBServiceOptions_FieldNumber) {
  GPBServiceOptions_FieldNumber_Deprecated = 33,
  GPBServiceOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBServiceOptions : GPBMessage

// Is this service deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the service, or it will be completely ignored; in the very least,
// this is a formalization for deprecating services.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBMethodOptions

typedef GPB_ENUM(GPBMethodOptions_FieldNumber) {
  GPBMethodOptions_FieldNumber_Deprecated = 33,
  GPBMethodOptions_FieldNumber_UninterpretedOptionArray = 999,
};

@interface GPBMethodOptions : GPBMessage

// Is this method deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the method, or it will be completely ignored; in the very least,
// this is a formalization for deprecating methods.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;

// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong) NSMutableArray *uninterpretedOptionArray;

@end

#pragma mark - GPBUninterpretedOption

typedef GPB_ENUM(GPBUninterpretedOption_FieldNumber) {
  GPBUninterpretedOption_FieldNumber_NameArray = 2,
  GPBUninterpretedOption_FieldNumber_IdentifierValue = 3,
  GPBUninterpretedOption_FieldNumber_PositiveIntValue = 4,
  GPBUninterpretedOption_FieldNumber_NegativeIntValue = 5,
  GPBUninterpretedOption_FieldNumber_DoubleValue = 6,
  GPBUninterpretedOption_FieldNumber_StringValue = 7,
  GPBUninterpretedOption_FieldNumber_AggregateValue = 8,
};

// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
@interface GPBUninterpretedOption : GPBMessage

// |nameArray| contains |GPBUninterpretedOption_NamePart|
@property(nonatomic, readwrite, strong) NSMutableArray *nameArray;

// The value of the uninterpreted option, in whatever type the tokenizer
// identified it as during parsing. Exactly one of these should be set.
@property(nonatomic, readwrite) BOOL hasIdentifierValue;
@property(nonatomic, readwrite, copy) NSString *identifierValue;

@property(nonatomic, readwrite) BOOL hasPositiveIntValue;
@property(nonatomic, readwrite) uint64_t positiveIntValue;

@property(nonatomic, readwrite) BOOL hasNegativeIntValue;
@property(nonatomic, readwrite) int64_t negativeIntValue;

@property(nonatomic, readwrite) BOOL hasDoubleValue;
@property(nonatomic, readwrite) double doubleValue;

@property(nonatomic, readwrite) BOOL hasStringValue;
@property(nonatomic, readwrite, copy) NSData *stringValue;

@property(nonatomic, readwrite) BOOL hasAggregateValue;
@property(nonatomic, readwrite, copy) NSString *aggregateValue;

@end

#pragma mark - GPBUninterpretedOption_NamePart

typedef GPB_ENUM(GPBUninterpretedOption_NamePart_FieldNumber) {
  GPBUninterpretedOption_NamePart_FieldNumber_NamePart = 1,
  GPBUninterpretedOption_NamePart_FieldNumber_IsExtension = 2,
};

// The name of the uninterpreted option.  Each string represents a segment in
// a dot-separated name.  is_extension is true iff a segment represents an
// extension (denoted with parentheses in options specs in .proto files).
// E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
// "foo.(bar.baz).qux".
@interface GPBUninterpretedOption_NamePart : GPBMessage

@property(nonatomic, readwrite) BOOL hasNamePart;
@property(nonatomic, readwrite, copy) NSString *namePart;

@property(nonatomic, readwrite) BOOL hasIsExtension;
@property(nonatomic, readwrite) BOOL isExtension;

@end

#pragma mark - GPBSourceCodeInfo

typedef GPB_ENUM(GPBSourceCodeInfo_FieldNumber) {
  GPBSourceCodeInfo_FieldNumber_LocationArray = 1,
};

// Encapsulates information about the original source file from which a
// FileDescriptorProto was generated.
@interface GPBSourceCodeInfo : GPBMessage

// A Location identifies a piece of source code in a .proto file which
// corresponds to a particular definition.  This information is intended
// to be useful to IDEs, code indexers, documentation generators, and similar
// tools.
//
// For example, say we have a file like:
//   message Foo {
//     optional string foo = 1;
//   }
// Let's look at just the field definition:
//   optional string foo = 1;
//   ^       ^^     ^^  ^  ^^^
//   a       bc     de  f  ghi
// We have the following locations:
//   span   path               represents
//   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
//   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
//   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
//   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
//   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
//
// Notes:
// - A location may refer to a repeated field itself (i.e. not to any
//   particular index within it).  This is used whenever a set of elements are
//   logically enclosed in a single code segment.  For example, an entire
//   extend block (possibly containing multiple extension definitions) will
//   have an outer location whose path refers to the "extensions" repeated
//   field without an index.
// - Multiple locations may have the same path.  This happens when a single
//   logical declaration is spread out across multiple places.  The most
//   obvious example is the "extend" block again -- there may be multiple
//   extend blocks in the same scope, each of which will have the same path.
// - A location's span is not always a subset of its parent's span.  For
//   example, the "extendee" of an extension declaration appears at the
//   beginning of the "extend" block and is shared by all extensions within
//   the block.
// - Just because a location's span is a subset of some other location's span
//   does not mean that it is a descendent.  For example, a "group" defines
//   both a type and a field in a single declaration.  Thus, the locations
//   corresponding to the type and field and their components will overlap.
// - Code which tries to interpret locations should probably be designed to
//   ignore those that it doesn't understand, as more types of locations could
//   be recorded in the future.
// |locationArray| contains |GPBSourceCodeInfo_Location|
@property(nonatomic, readwrite, strong) NSMutableArray *locationArray;

@end

#pragma mark - GPBSourceCodeInfo_Location

typedef GPB_ENUM(GPBSourceCodeInfo_Location_FieldNumber) {
  GPBSourceCodeInfo_Location_FieldNumber_PathArray = 1,
  GPBSourceCodeInfo_Location_FieldNumber_SpanArray = 2,
  GPBSourceCodeInfo_Location_FieldNumber_LeadingComments = 3,
  GPBSourceCodeInfo_Location_FieldNumber_TrailingComments = 4,
  GPBSourceCodeInfo_Location_FieldNumber_LeadingDetachedCommentsArray = 6,
};

@interface GPBSourceCodeInfo_Location : GPBMessage

// Identifies which part of the FileDescriptorProto was defined at this
// location.
//
// Each element is a field number or an index.  They form a path from
// the root FileDescriptorProto to the place where the definition.  For
// example, this path:
//   [ 4, 3, 2, 7, 1 ]
// refers to:
//   file.message_type(3)  // 4, 3
//       .field(7)         // 2, 7
//       .name()           // 1
// This is because FileDescriptorProto.message_type has field number 4:
//   repeated DescriptorProto message_type = 4;
// and DescriptorProto.field has field number 2:
//   repeated FieldDescriptorProto field = 2;
// and FieldDescriptorProto.name has field number 1:
//   optional string name = 1;
//
// Thus, the above path gives the location of a field name.  If we removed
// the last element:
//   [ 4, 3, 2, 7 ]
// this path refers to the whole field declaration (from the beginning
// of the label to the terminating semicolon).
@property(nonatomic, readwrite, strong) GPBInt32Array *pathArray;

// Always has exactly three or four elements: start line, start column,
// end line (optional, otherwise assumed same as start line), end column.
// These are packed into a single field for efficiency.  Note that line
// and column numbers are zero-based -- typically you will want to add
// 1 to each before displaying to a user.
@property(nonatomic, readwrite, strong) GPBInt32Array *spanArray;

// If this SourceCodeInfo represents a complete declaration, these are any
// comments appearing before and after the declaration which appear to be
// attached to the declaration.
//
// A series of line comments appearing on consecutive lines, with no other
// tokens appearing on those lines, will be treated as a single comment.
//
// leading_detached_comments will keep paragraphs of comments that appear
// before (but not connected to) the current element. Each paragraph,
// separated by empty lines, will be one comment element in the repeated
// field.
//
// Only the comment content is provided; comment markers (e.g. //) are
// stripped out.  For block comments, leading whitespace and an asterisk
// will be stripped from the beginning of each line other than the first.
// Newlines are included in the output.
//
// Examples:
//
//   optional int32 foo = 1;  // Comment attached to foo.
//   // Comment attached to bar.
//   optional int32 bar = 2;
//
//   optional string baz = 3;
//   // Comment attached to baz.
//   // Another line attached to baz.
//
//   // Comment attached to qux.
//   //
//   // Another line attached to qux.
//   optional double qux = 4;
//
//   // Detached comment for corge. This is not leading or trailing comments
//   // to qux or corge because there are blank lines separating it from
//   // both.
//
//   // Detached comment for corge paragraph 2.
//
//   optional string corge = 5;
//   /* Block comment attached
//    * to corge.  Leading asterisks
//    * will be removed. */
//   /* Block comment attached to
//    * grault. */
//   optional int32 grault = 6;
//
//   // ignored detached comments.
@property(nonatomic, readwrite) BOOL hasLeadingComments;
@property(nonatomic, readwrite, copy) NSString *leadingComments;

@property(nonatomic, readwrite) BOOL hasTrailingComments;
@property(nonatomic, readwrite, copy) NSString *trailingComments;

// |leadingDetachedCommentsArray| contains |NSString|
@property(nonatomic, readwrite, strong) NSMutableArray *leadingDetachedCommentsArray;

@end

CF_EXTERN_C_END

// @@protoc_insertion_point(global_scope)
