import base58
import hashlib

# Might want to switch these out with something generated by tinyber?
from pyasn1.type import univ, namedtype
from pyasn1.codec.der import encoder, decoder

from two1.bitcoin.utils import bytes_to_str
from two1.crypto.ecdsa import ECPointAffine, ECPointJacobian, EllipticCurve, secp256k1

bitcoin_curve = secp256k1()

class ECDERPoint(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType("r", univ.Integer()),
        namedtype.NamedType("s", univ.Integer())
    )


def der_encode_point(pt):
    ''' Encodes an ECPointAffine using DER.

        Two components are encoded: r = pt.x and s = pt.y.

    Args:
        pt (ECPointAffine): The point to be encoded.

    Returns:
        dep (bytes): The DER encoding of pt.
    '''
    ep = ECDERPoint()
    ep.setComponentByName('r', pt.x)
    ep.setComponentByName('s', pt.y)

    return encoder.encode(ep)

def der_encode_hex(pt):
    ''' Returns a hex string of the result from der_encode_point()

    Args:
        pt (ECPointAffine): The point to be encoded.

    Returns:
        dep (str): DER encoded point as a hex string.
    '''
    enc = der_encode(pt)
    return bytes_to_str(enc)

def der_decode_point(curve, der):
    ''' Decodes an ECPoint that was DER-encoded.

    Args:
        curve (EllipticCurve): The curve the point is on.
        der (bytes): The DER encoding to be decoded.

    Returns:
        pt (ECPointAffine): The decoded point.
    '''
    d = decoder.decode(der)[0]
    x = int(d.getComponentByPosition(0))
    y = int(d.getComponentByPosition(1))

    return ECPointAffine(curve, x, y)

def decode_private_key(private_key, testnet=False):
    ''' Decodes a Base58Check encoded private-key.

    Args:
        private_key (str): A Base58Check encoded private key.
        testnet (bool) (Optional): Changes the expected version.

    Returns:
        pk (Bignum): The integer value of the private key.
    '''
    version = 0xEF if testnet else 0x80
    b58dec = base58.b58decode_check(private_key)
    assert b58dec[0] == version
        
    return int.from_bytes(b58dec[1:], 'big')

def decode_public_key(key):
    ''' Decodes BTC representation of compressed/uncompressed public keys.

    Args:
        key (str): A hex-encoded key string.
        
    Returns:
        pt (ECPointAffine): The point on the secp256k1 curve corresponding to key.
    '''
    key_bytes = bytes.fromhex(key)
    key_bytes_len = len(key_bytes)

    key_type = int(key[0:2])
    if key_type == 0x04:
        ## Uncompressed
        assert key_bytes_len == 65
        
        x = int.from_bytes(key_bytes[1:32], 'big')
        y = int.from_bytes(key_bytes[32:65], 'big')
    elif key_type == 0x02 or key_type == 0x03:
        assert key_bytes_len == 33
        x = int.from_bytes(key_bytes[1:32], 'big')
        y = bitcoin_curve.y_from_x(x)
        if y % 2 != (key_type - 2):
            y = -y % bitcoin_curve.p
    else:
        return None

    p = ECPointAffine(bitcoin_curve, x, y)
    assert bitcoin_curve.is_on_curve(p)
    return p

def gen_key_pair(testnet=False):
    ''' Generates a private/public key pair on the secp256k1 curve.
        
    Args:
        testnet (bool) (Optional): If True, changes the version.

    Returns:
        (private_key, public_key) (tuple): a tuple consisting of a 
            Base58 encoded private key and a DER encoded public key.
    '''
    priv, pub_full = bitcoin_curve.gen_key_pair()

    # Formulate the public key properly
    pub_pt = ECPointAffine.from_int(bitcoin_curve, pub_full)
    pub_der = der_encode_point(pub_pt)

    version = 0xEF if testnet else 0x80
    priv_bytes = bytes([version]) + priv.to_bytes(32, 'big')
    priv_enc = base58.b58encode_check(priv_bytes)
        
    return priv_enc, pub_der

def get_public_key(private_key):
    ''' Returns the public (verifying) key for a given private key.
    
    Args:
        private_key (str): the Base58Check encodedprivate key to 
           derive the public key for.

    Returns:
        public_full (str): A DER-encoded hex string containing the public
           key corresponding to private_key.
    '''
    return der_encode_point(ECPointAffine.from_int(bitcoin_curve.public_key(private_key)))

def raw_sign(message, private_key, testnet=False):
    ''' Signs message using Base58Check encoded private key.

    Args:
        message (bytes): The message to be signed.
        private_key (str): A Base58Check encoded private key.
        testnet (bool) (Optional): If True, changes the version.

    Returns:
        pt (ECPointAffine): a raw point (r = pt.x, s = pt.y) which is the signature.
    '''
    return bitcoin_curve.sign(message, decode_private_key(private_key, testnet))

def sign(message, private_key, testnet=False):
    ''' Signs message using Base58Check encoded private key.

    Note:
        This differs from `raw_sign()` since it returns a DER encoding
        of the signature point.

    Args:
        message (bytes): The message to be signed.
        private_key (str): A Base58Check encoded private key.
        testnet (bool) (Optional): If True, changes the version.

    Returns:
        pt (bytes): DER-encoded representation of the signature point.
    '''

    # Returns a DER encoded signature of message as a byte string.

    return der_encode_point(raw_sign(message, private_key, testnet))

def verify_signature(message, signature, public_key):
    ''' Verifies that message was appropriately signed.

    Args:
        message (bytes): The message to be verified.
        signature (str): Hex string of a DER-encoded signature.
        public_key (str): Hex string of a DER-encoded public key.

    Returns:
        verified (bool): True if the signature is verified, False otherwise.
    '''
    sig_pt = der_decode_point(bitcoin_curve, bytes.fromhex(signature))
    
    # Decode the public_key
    pk = der_decode_point(bitcoin_curve, bytes.fromhex(public_key))
    return bitcoin_curve.verify(message, sig_pt, pk)

def address_from_public_key(public_key, encode=True, testnet=False):
    ''' Generates a valid Bitcoin address corresponding to a public key.
    
        This is done by taking the RIPEMD-160 hash of the SHA-256 hash
        of the public key and the Base58Check encoding the result.

    Args:
        public_key (bytes): DER-encoded public key.
        encode (bool) (Optional): If True, Base58Check encodes the address,
           otherwise returns the version + the RIPEMD-160 hash of the public_key.
        testnet (bool) (Optional): If True, changes the version.        
    
    Returns:
        address (str or bytes): A Base58Check encoded bitcoin address if encode=True.
           Otherwise, bytes containing the RIPEMD-160 hash
    '''
    pk_pt = der_decode_point(bitcoin_curve, bytes.fromhex(public_key))
    
    ## First take SHA-256 of uncompressed public key
    pk_bytes = bytes([0x04]) + pk_pt.x.to_bytes(32, 'big') + pk_pt.y.to_bytes(32, 'big')
    pk_sha = hashlib.sha256(pk_bytes).digest()
    
    ## RIPEMD-160 of SHA-256
    r = hashlib.new('ripemd160')
    r.update(pk_sha)
    ripe = r.digest()

    ## Put the version byte in front, 0x00 for Mainnet, 0x6F for testnet
    version = bytes([0x6F]) if testnet else bytes([0x00])

    if encode:
        return base58.b58encode_check(version + ripe)
    else:
        return version + ripe

if __name__ == "__main__":
    private_key, enc_pub_key = gen_key_pair()

    pub_key_aff = der_decode_point(bitcoin_curve, enc_pub_key)
    print("public key affine point: %s" % pub_key_aff)
    pub_key_jac = ECPointJacobian.from_affine(pub_key_aff)
    print("public key jacobian point: %s" % pub_key_jac)

    pub_key_jac_2 = pub_key_jac * 2
    print("2 * pub_key_jac = %s" % (pub_key_jac_2))
    print("(2 * pub_key_jac).to_affine() = %s" % pub_key_jac_2.to_affine())

    pub_key_aff_2 = pub_key_aff * 2
    print("2 * pub_key_aff = %s" % (pub_key_aff_2))
    
    pub_key_hex = bytes_to_str(enc_pub_key)
    pk_hex = bytes_to_str(base58.b58decode_check(private_key))
    print("private key = %s, len = %d" % (pk_hex, len(pk_hex)))
    print("public key = %s" % pub_key_hex)
    print("public key address = %s" % addr_from_public_key(pub_key_hex))
    
    message = b"foobar"
    sig = sign(message, private_key)
    sig_hex = bytes_to_str(sig)
    print("signature = %s" % sig_hex)
    sig_ver = verify_signature(message, sig_hex, pub_key_hex)
    print("signature verified: %r" % (sig_ver))

