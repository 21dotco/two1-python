import base58
import hashlib
import math
import random

# Might want to switch these out with something generated by tinyber?
from pyasn1.type import univ, namedtype
from pyasn1.codec.der import encoder, decoder

from two1.bitcoin.utils import bytes_to_str, address_to_key_hash
from two1.crypto.ecdsa import ECPointAffine, ECPointJacobian, EllipticCurve, secp256k1

bitcoin_curve = secp256k1()


def get_bytes(s):
    if isinstance(s, bytes):
        b = s
    elif isinstance(s, str):
        b = bytes.fromhex(s)
    else:
        raise TypeError("s must be either 'bytes' or 'str'!")

    return b
    
class PrivateKey(object):
    TESTNET_VERSION = 0xEF
    MAINNET_VERSION = 0x80

    @staticmethod
    def from_int(i, testnet=False):
        return PrivateKey(i, testnet)

    @staticmethod
    def from_b58check(private_key):
        ''' Decodes a Base58Check encoded private-key.

        Args:
            private_key (str): A Base58Check encoded private key.

        Returns:
            pk (PrivateKey): A PrivateKey object
        '''
        b58dec = base58.b58decode_check(private_key)
        version = b58dec[0]
        assert version in [PrivateKey.TESTNET_VERSION, PrivateKey.MAINNET_VERSION]
        
        return PrivateKey(int.from_bytes(b58dec[1:], 'big'), version == PrivateKey.TESTNET_VERSION)

    @staticmethod
    def from_random(testnet=False):
        return PrivateKey(random.SystemRandom().randrange(1, bitcoin_curve.n - 1), testnet)

    def __init__(self, k, testnet=False):
        self.key = k
        self.version = self.TESTNET_VERSION if testnet else self.MAINNET_VERSION
        self._public_key = PublicKey.from_int(bitcoin_curve.public_key(self.key), testnet)

    @property
    def public_key(self):
        return self._public_key

    def raw_sign(self, message):
        ''' Signs message using this private key.

        Args:
            message (bytes): The message to be signed.

        Returns:
            pt (ECPointAffine): a raw point (r = pt.x, s = pt.y) which is the signature.
        '''
        return bitcoin_curve.sign(message, self.key)

    def sign(self, message, determine_recovery_id=False):
        ''' Signs message using this private key.

        Note:
            This differs from `raw_sign()` since it returns a Signature object.

        Args:
            message (bytes): The message to be signed.

        Returns:
            sig (Signature): The signature corresponding to message.
        '''
        # Some BTC things want to have the recovery id to extract the public
        # key, so we should figure that out.
        recovery_id = None
        sig_pt = self.raw_sign(message)
        print(sig_pt)

        if determine_recovery_id:
            keys = bitcoin_curve.recover_public_key(message, sig_pt)
            for k, recid in keys:
                if k.x == self.public_key.point.x and k.y == self.public_key.point.y:
                    recovery_id = recid
                    break

        return Signature(sig_pt.x, sig_pt.y, recovery_id)

    def to_b58check(self):
        return base58.b58encode_check(bytes(self))

    def to_hex(self):
        return bytes_to_str(bytes(self))

    def __bytes__(self):
        return bytes([self.version]) + self.key.to_bytes(32, 'big')

    def __int__(self):
        return self.key

    
class PublicKey(object):
    TESTNET_VERSION = 0x6F
    MAINNET_VERSION = 0x00

    @staticmethod
    def from_point(p, testnet=False):
        return PublicKey(p.x, p.y, testnet)
    
    @staticmethod
    def from_int(i, testnet=False):
        point = ECPointAffine.from_int(bitcoin_curve, i)
        return PublicKey.from_point(point, testnet)
        
    @staticmethod
    def from_bytes(key_bytes, testnet=False):
        key_bytes_len = len(key_bytes)

        key_type = key_bytes[0]
        if key_type == 0x04:
            # Uncompressed
            assert key_bytes_len == 65

            x = int.from_bytes(key_bytes[1:33], 'big')
            y = int.from_bytes(key_bytes[33:65], 'big')
        elif key_type == 0x02 or key_type == 0x03:
            assert key_bytes_len == 33
            x = int.from_bytes(key_bytes[1:33], 'big')
            ys = bitcoin_curve.y_from_x(x)

            # Pick the one that corresponds to key_type
            last_bit = key_type - 0x2
            for y in ys:
                if y & 0x1 == last_bit:
                    break
        else:
            return None

        return PublicKey(x, y, testnet)

    @staticmethod
    def from_hex(h, testnet=False):
        return PublicKey.from_bytes(bytes.fromhex(h), testnet)

    @staticmethod
    def from_private_key(private_key):
        return private_key.public_key

    @staticmethod
    def from_signature(message, signature, testnet=False):
        ''' Attempts to create PublicKey object by deriving it
            from the message and signature.

        Args:
            message (bytes): The message to be verified.
            signature (Signature): The signature for message.
               The recovery_id must not be None!

        Returns:
            p (PublicKey): A PublicKey object derived from the
               signature, it it exists. None otherwise.
        '''
        msg = get_bytes(message)
        pub_keys = bitcoin_curve.recover_public_key(msg, signature)
        
        for k, recid in pub_keys:
            if signature.recovery_id is not None and recid == signature.recovery_id:
                return PublicKey(k.x, k.y, testnet)

        return None
    
    def __init__(self, x, y, testnet=False):
        p = ECPointAffine(bitcoin_curve, x, y)
        assert bitcoin_curve.is_on_curve(p)

        self.point = p
        self.testnet = testnet

        pk_sha = hashlib.sha256(bytes(self)).digest()
    
        # RIPEMD-160 of SHA-256
        r = hashlib.new('ripemd160')
        r.update(pk_sha)
        ripe = r.digest()

        # Put the version byte in front, 0x00 for Mainnet, 0x6F for testnet
        version = bytes([self.TESTNET_VERSION]) if self.testnet else bytes([self.MAINNET_VERSION])

        self._address = version + ripe
        self._b58address = base58.b58encode_check(self._address)

    @property
    def address(self):
        return self._address
        
    @property
    def b58address(self):
        return self._b58address

    def verify(self, message, signature):
        ''' Verifies that message was appropriately signed.

        Args:
            message (bytes): The message to be verified.
            signature (Signature): A signature object.

        Returns:
            verified (bool): True if the signature is verified, False otherwise.
        '''
        msg = get_bytes(message)
        return bitcoin_curve.verify(msg, signature, self.point)
    
    def to_hex(self):
        return bytes_to_str(bytes(self))

    def __int__(self):
        return (self.point.x << bitcoin_curve.n.bit_length()) + self.point.y

    def __bytes__(self):
        return bytes(self.point)

    @property
    def compressed_bytes(self):
        return self.point.compressed_bytes


class Signature(object):

    class ECDERPoint(univ.Sequence):
        componentType = namedtype.NamedTypes(
            namedtype.NamedType("r", univ.Integer()),
            namedtype.NamedType("s", univ.Integer())
        )

    @staticmethod
    def from_der(der):
        ''' Decodes a Signature that was DER-encoded.

        Args:
            der (bytes or str): The DER encoding to be decoded.

        Returns:
            s (Signature): The deserialized signature.
        '''
        if isinstance(der, bytes):
            d = decoder.decode(der)[0]
        elif isinstance(der, str):
            d = decoder.decode(bytes.fromhex(der))[0]
        else:
            raise TypeError("der must be either 'bytes' or 'str'")
    
        r = int(d.getComponentByPosition(0))
        s = int(d.getComponentByPosition(1))

        return Signature(r, s)

    @staticmethod
    def from_bytes(b):
        r = b[0:32]
        s = b[33:64]
        return Signature(r, s)
    
    def __init__(self, r, s, recovery_id=None):
        self.r = r
        self.s = s
        self.recovery_id = recovery_id

    @property
    def x(self):
        return self.r

    @property
    def y(self):
        return self.s
        
    def to_der(self):
        ''' Encodes this signature using DER

        Returns:
            dep (bytes): The DER encoding of (self.r, self.s).
        '''
        ep = Signature.ECDERPoint()
        ep.setComponentByName('r', self.r)
        ep.setComponentByName('s', self.s)

        return encoder.encode(ep)

    def __bytes__(self):
        nbytes = math.ceil(bitcoin_curve.n.bit_length() // 8)
        return self.r.to_bytes(nbytes, 'big') + self.s.to_bytes(nbytes, 'big')

    
if __name__ == "__main__":
    private_key = PrivateKey.from_random()
    public_key = private_key.public_key

    pk_hex = private_key.to_hex()
    print("private key = %s, len = %d" % (pk_hex, len(pk_hex)))
    print("public key = %s" % public_key.to_hex())
    print("public key address = %s" % public_key.b58address)
    
    message = b"foobar"
    sig = private_key.sign(message)
    sig_hex = bytes_to_str(sig)
    print("signature = %s" % sig_hex)
    sig_ver = public_key.verify(message, sig)
    print("signature verified: %r" % (sig_ver))

