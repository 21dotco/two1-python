# -*- Mode: Python -*-
# generated by: tinyber_gen -l python -o gen/python/ laminar.asn1
# *** do not edit ***

# --- start codec.py ---

# -*- Mode: Python -*-

# base for python codecs.

# NOTE: the encoder accumulates in *reverse*.


class DecodingError(Exception):
    pass


class IndefiniteLength(DecodingError):
    pass


class ElementTooLarge(DecodingError):
    pass


class Underflow(DecodingError):
    pass


class UnexpectedType(DecodingError):
    pass


class UnexpectedFlags(DecodingError):
    pass


class ConstraintViolation(DecodingError):
    pass


class BadChoice(DecodingError):
    pass


class ExtraData(DecodingError):
    pass


class FLAG:
    UNIVERSAL = 0x00
    STRUCTURED = 0x20
    APPLICATION = 0x40
    CONTEXT = 0x80


class TAG:
    BOOLEAN = 0x01
    INTEGER = 0x02
    BITSTRING = 0x03
    OCTETSTRING = 0x04
    NULLTAG = 0x05
    OID = 0x06
    ENUMERATED = 0x0A
    UTF8STRING = 0x0C
    SEQUENCE = 0x10
    SET = 0x11


class Decoder:

    def __init__(self, data, pos=0, end=None):
        self.data = data
        self.pos = pos
        if end is None:
            end = len(data)
        self.end = end

    def pop_byte(self):
        if self.pos + 1 > self.end:
            raise Underflow(self)
        else:
            try:
                val = ord(self.data[self.pos])
            except TypeError:
                val = self.data[self.pos]
            self.pos += 1
            return val

    def pop(self, nbytes):
        if self.pos + nbytes > self.end:
            raise Underflow(self)
        else:
            r = Decoder(self.data, self.pos, self.pos + nbytes)
            self.pos += nbytes
            return r

    def pop_bytes(self, nbytes):
        if self.pos + nbytes > self.end:
            raise Underflow(self)
        else:
            result = self.data[self.pos:self.pos+nbytes]
            self.pos += nbytes
            return result

    def done(self):
        return self.pos == self.end

    def assert_done(self):
        if self.pos != self.end:
            raise ExtraData(self)

    def get_length(self):
        val = self.pop_byte()
        if val < 0x80:
            # one-byte length
            return val
        elif val == 0x80:
            raise IndefiniteLength(self)
        else:
            # get length of length
            lol = val & 0x7f
            if lol > 4:
                raise ElementTooLarge(self)
            else:
                n = 0
                while lol:
                    n = (n << 8) | self.pop_byte()
                    lol -= 1
                return n

    def get_multibyte_tag(self):
        r = 0
        while 1:
            val = self.pop_byte()
            r <<= 7
            r |= val & 0x7f
            if not val & 0x80:
                break
        return r

    def get_tag(self):
        b = self.pop_byte()
        tag = b & 0b11111
        flags = b & 0b1100000
        if tag == 0b11111:
            tag = self.get_multibyte_tag()
        return tag, flags

    def check(self, expected_tag, expected_flags=0):
        tag, flags = self.get_tag()
        if tag != expected_tag:
            raise UnexpectedType(tag, expected_tag)
        if flags != expected_flags:
            raise UnexpectedFlags(flags, expected_flags)

    def next(self, expected, flags=0):
        self.check(expected, flags)
        length = self.get_length()
        return self.pop(length)

    def get_integer(self, length):
        if length == 0:
            return 0
        else:
            n = self.pop_byte()
            length -= 1
            if n & 0x80:
                # negative
                n -= 0x100
            else:
                while length:
                    n = n << 8 | self.pop_byte()
                    length -= 1
                return n

    def next_INTEGER(self, min_val, max_val):
        self.check(TAG.INTEGER)
        r = self.get_integer(self.get_length())
        if min_val is not None and r < min_val:
            raise ConstraintViolation(r, min_val)
        if max_val is not None and r > max_val:
            raise ConstraintViolation(r, max_val)
        return r

    def next_OCTET_STRING(self, min_size, max_size):
        self.check(TAG.OCTETSTRING)
        r = self.pop_bytes(self.get_length())
        if min_size is not None and len(r) < min_size:
            raise ConstraintViolation(r, min_size)
        if max_size is not None and len(r) > max_size:
            raise ConstraintViolation(r, max_size)
        return r

    def next_BOOLEAN(self):
        self.check(TAG.BOOLEAN)
        assert(self.pop_byte() == 1)
        return self.pop_byte() != 0

    def next_ENUMERATED(self):
        self.check(TAG.ENUMERATED)
        return self.get_integer(self.get_length())

    def next_APPLICATION(self):
        tag, flags = self.get_tag()
        if not flags & FLAG.APPLICATION:
            raise UnexpectedFlags(self, flags, FLAG.APPLICATION)
        else:
            return tag, self.pop(self.get_length())


class EncoderContext:

    def __init__(self, enc, tag, flags):
        self.enc = enc
        self.tag = tag
        self.flags = flags
        self.pos = enc.length

    def __enter__(self):
        pass

    def __exit__(self, t, v, tb):
        self.enc.emit_length(self.enc.length - self.pos)
        self.enc.emit_tag(self.tag, self.flags)


class Encoder:

    def __init__(self):
        self.r = []
        self.length = 0

    def _chr(self, x):
        return bytearray((x,))

    def emit(self, data):
        self.r.insert(0, data)
        self.length += len(data)

    def emit_length(self, n):
        if n < 0x80:
            self.emit(self._chr(n))
        else:
            r = []
            while n:
                r.insert(0, self._chr(n & 0xff))
                n >>= 8
            r.insert(0, self._chr(0x80 | len(r)))
            self.emit(b''.join(r))

    def emit_tag(self, tag, flags=0):
        if tag < 0x1f:
            self.emit(self._chr(tag | flags))
        else:
            while tag:
                if tag < 0x80:
                    self.emit(self._chr(tag))
                else:
                    self.emit(self._chr((tag & 0x7f) | 0x80))
                tag >>= 7
            self.emit(self._chr(0x1f | flags))

    def TLV(self, tag, flags=0):
        return EncoderContext(self, tag, flags)

    def done(self):
        return b''.join(self.r)

    # base types

    # encode an integer, ASN1 style.
    # two's complement with the minimum number of bytes.
    def emit_integer(self, n):
        i = 0
        n0 = n
        byte = 0x80
        r = []
        while 1:
            n >>= 8
            if n0 == n:
                if n == -1 and ((not byte & 0x80) or i == 0):
                    # negative, but high bit clear
                    r.insert(0, self._chr(0xff))
                    i = i + 1
                elif n == 0 and (byte & 0x80):
                    # positive, but high bit set
                    r.insert(0, self._chr(0x00))
                    i = i + 1
                break
            else:
                byte = n0 & 0xff
                r.insert(0, self._chr(byte))
                i += 1
                n0 = n
        self.emit(b''.join(r))

    def emit_INTEGER(self, n):
        with self.TLV(TAG.INTEGER):
            self.emit_integer(n)

    def emit_OCTET_STRING(self, s):
        with self.TLV(TAG.OCTETSTRING):
            self.emit(s)

    def emit_BOOLEAN(self, v):
        with self.TLV(TAG.BOOLEAN):
            if v:
                self.emit(b'\xff')
            else:
                self.emit(b'\x00')


class ASN1:
    value = None

    def __init__(self, value=None):
        self.value = value

    def encode(self):
        e = Encoder()
        self._encode(e)
        return e.done()

    def decode(self, data):
        b = Decoder(data)
        self._decode(b)
    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__, self.value)


class SEQUENCE(ASN1):
    __slots__ = ()

    def __init__(self, **args):
        for k, v in args.items():
            setattr(self, k, v)

    def __repr__(self):
        r = []
        for name in self.__slots__:
            r.append('%s=%r' % (name, getattr(self, name)))
        return '<%s %s>' % (self.__class__.__name__, ' '.join(r))


class CHOICE(ASN1):
    tags_f = {}
    tags_r = {}

    def _decode(self, src):
        tag, src = src.next_APPLICATION()
        self.value = self.tags_r[tag]()
        self.value._decode(src)

    def _encode(self, dst):
        for klass, tag in self.tags_f.items():
            if isinstance(self.value, klass):
                with dst.TLV(tag, FLAG.APPLICATION | FLAG.STRUCTURED):
                    self.value._encode(dst)
                    return
        raise BadChoice(self.value)


class ENUMERATED(ASN1):
    tags_f = {}
    tags_r = {}
    value = 'NoValueDefined'

    def _decode(self, src):
        v = src.next_ENUMERATED()
        self.value = self.tags_r[v]

    def _encode(self, dst):
        with dst.TLV(TAG.ENUMERATED):
            dst.emit_integer(self.tags_f[self.value])

    def __repr__(self):
        return '<%s %s>' % (self.__class__.__name__, self.value)


# try to pull in cython version if available.
try:
    from tinyber._codec import *
except ImportError:
    pass

# --- end codec.py ---


class FixedPoint(ASN1):
    max_size = 5

    def _decode(self, src):
        v = src.next_INTEGER(0, 65535)
        self.value = v

    def _encode(self, dst):
        dst.emit_INTEGER(self.value)


class AuthReplyYes(SEQUENCE):
    max_size = 23
    __slots__ = (
        'enonce1',
        'enonce2_size',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_OCTET_STRING(0, 16)
        self.enonce1 = v
        v = src.next_INTEGER(0, 16)
        self.enonce2_size = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_INTEGER(self.enonce2_size)
            dst.emit_OCTET_STRING(self.enonce1)


class BitsplitAuthRequest(SEQUENCE):
    max_size = 45
    __slots__ = (
        'version',
        'uuid',
        'mac',
        'protocol',
        'numerator',
        'denominator',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 255)
        self.version = v
        v = src.next_OCTET_STRING(16, 16)
        self.uuid = v
        v = src.next_OCTET_STRING(6, 6)
        self.mac = v
        v = src.next_INTEGER(0, 4294967295)
        self.protocol = v
        v = src.next_INTEGER(0, 100)
        self.numerator = v
        v = src.next_INTEGER(0, 100)
        self.denominator = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_INTEGER(self.denominator)
            dst.emit_INTEGER(self.numerator)
            dst.emit_INTEGER(self.protocol)
            dst.emit_OCTET_STRING(self.mac)
            dst.emit_OCTET_STRING(self.uuid)
            dst.emit_INTEGER(self.version)


class IPv4(ASN1):
    max_size = 6

    def _decode(self, src):
        v = src.next_OCTET_STRING(4, 4)
        self.value = v

    def _encode(self, dst):
        dst.emit_OCTET_STRING(self.value)


class MinMaxAvg(SEQUENCE):
    max_size = 17
    __slots__ = (
        'min',
        'max',
        'avg',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = FixedPoint()
        v._decode(src)
        self.min = v
        v = FixedPoint()
        v._decode(src)
        self.max = v
        v = FixedPoint()
        v._decode(src)
        self.avg = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.avg._encode(dst)
            self.max._encode(dst)
            self.min._encode(dst)


class LargeSystemBoardTemp(SEQUENCE):
    max_size = 19
    __slots__ = (
        'temp',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = MinMaxAvg()
        v._decode(src)
        self.temp = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.temp._encode(dst)


class SubmitStatus(ENUMERATED):
    max_size = 3
    tags_f = {
        'good': 0,
        'bad': 1,
        'stale': 2,
        'duplicate': 3,
    }
    tags_r = {
        0: 'good',
        1: 'bad',
        2: 'stale',
        3: 'duplicate',
    }


class SubmitReply(SEQUENCE):
    max_size = 12
    __slots__ = (
        'message_id',
        'result',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 4294967295)
        self.message_id = v
        v = SubmitStatus()
        v._decode(src)
        self.result = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.result._encode(dst)
            dst.emit_INTEGER(self.message_id)


class BroadcastMode(ENUMERATED):
    max_size = 3
    tags_f = {
        'notify-only': 0,
        'notify-and-submit': 1,
    }
    tags_r = {
        0: 'notify-only',
        1: 'notify-and-submit',
    }


class IPv6(ASN1):
    max_size = 18

    def _decode(self, src):
        v = src.next_OCTET_STRING(16, 16)
        self.value = v

    def _encode(self, dst):
        dst.emit_OCTET_STRING(self.value)


class IPAddress(CHOICE):
    max_size = 20
    tags_f = {
        IPv4: 0,
        IPv6: 1,
    }
    tags_r = {
        0: IPv4,
        1: IPv6,
    }


class Address(SEQUENCE):
    max_size = 27
    __slots__ = (
        'ip',
        'port',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = IPAddress()
        v._decode(src)
        self.ip = v
        v = src.next_INTEGER(0, 65535)
        self.port = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_INTEGER(self.port)
            self.ip._encode(dst)


class BroadcastRequest(SEQUENCE):
    max_size = 32
    __slots__ = (
        'mode',
        'address',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = BroadcastMode()
        v._decode(src)
        self.mode = v
        v = Address()
        v._decode(src)
        self.address = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.address._encode(dst)
            self.mode._encode(dst)


class Int16(ASN1):
    max_size = 4

    def _decode(self, src):
        v = src.next_INTEGER(-32768, 32767)
        self.value = v

    def _encode(self, dst):
        dst.emit_INTEGER(self.value)


class PoolDown(SEQUENCE):
    max_size = 108
    __slots__ = (
        'msg',
        'retry_seconds',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_OCTET_STRING(0, 100)
        self.msg = v
        v = src.next_INTEGER(0, 1800)
        self.retry_seconds = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_INTEGER(self.retry_seconds)
            dst.emit_OCTET_STRING(self.msg)


class Output(ASN1):
    max_size = 66

    def _decode(self, src):
        v = src.next_OCTET_STRING(1, 64)
        self.value = v

    def _encode(self, dst):
        dst.emit_OCTET_STRING(self.value)


class HasherStatus(SEQUENCE):
    max_size = 17
    __slots__ = (
        'freq',
        'good_cores',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = FixedPoint()
        v._decode(src)
        self.freq = v
        v = src.next_OCTET_STRING(8, 8)
        self.good_cores = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_OCTET_STRING(self.good_cores)
            self.freq._encode(dst)


class AuthRequest(SEQUENCE):
    max_size = 133
    __slots__ = (
        'version',
        'username',
        'worker',
        'password',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 255)
        self.version = v
        v = src.next_OCTET_STRING(1, 50)
        self.username = v
        v = src.next_OCTET_STRING(1, 20)
        self.worker = v
        v = src.next_OCTET_STRING(1, 50)
        self.password = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_OCTET_STRING(self.password)
            dst.emit_OCTET_STRING(self.worker)
            dst.emit_OCTET_STRING(self.username)
            dst.emit_INTEGER(self.version)


class Hash(ASN1):
    max_size = 34

    def _decode(self, src):
        v = src.next_OCTET_STRING(32, 32)
        self.value = v

    def _encode(self, dst):
        dst.emit_OCTET_STRING(self.value)


class Notify(SEQUENCE):
    max_size = 1124
    __slots__ = (
        'jobid',
        'block_version',
        'prev',
        'height',
        'bits',
        'itime',
        'iscript0',
        'iscript1',
        'outputs',
        'edge',
        'clear',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 65535)
        self.jobid = v
        v = src.next_INTEGER(0, 65535)
        self.block_version = v
        v = Hash()
        v._decode(src)
        self.prev = v
        v = src.next_INTEGER(0, 4294967295)
        self.height = v
        v = src.next_INTEGER(0, 4294967295)
        self.bits = v
        v = src.next_INTEGER(0, 4294967295)
        self.itime = v
        v = src.next_OCTET_STRING(0, 100)
        self.iscript0 = v
        v = src.next_OCTET_STRING(0, 100)
        self.iscript1 = v
        src, save = src.next(TAG.SEQUENCE, FLAG.STRUCTURED), src
        a = []
        while not src.done():
            v = Output()
            v._decode(src)
            a.append(v)
        if len(a) < 1:
            raise ConstraintViolation(a)
        if len(a) > 5:
            raise ConstraintViolation(a)
        v, src = a, save
        self.outputs = v
        src, save = src.next(TAG.SEQUENCE, FLAG.STRUCTURED), src
        a = []
        while not src.done():
            v = Hash()
            v._decode(src)
            a.append(v)
        if len(a) > 15:
            raise ConstraintViolation(a)
        v, src = a, save
        self.edge = v
        v = src.next_BOOLEAN()
        self.clear = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_BOOLEAN(self.clear)
            with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
                for v in reversed(self.edge):
                    v._encode(dst)
            with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
                for v in reversed(self.outputs):
                    v._encode(dst)
            dst.emit_OCTET_STRING(self.iscript1)
            dst.emit_OCTET_STRING(self.iscript0)
            dst.emit_INTEGER(self.itime)
            dst.emit_INTEGER(self.bits)
            dst.emit_INTEGER(self.height)
            self.prev._encode(dst)
            dst.emit_INTEGER(self.block_version)
            dst.emit_INTEGER(self.jobid)


class LargeSystemPol(SEQUENCE):
    max_size = 75
    __slots__ = (
        'status',
        'temp1',
        'temp2',
        'iout',
        'vout',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = FixedPoint()
        v._decode(src)
        self.status = v
        v = MinMaxAvg()
        v._decode(src)
        self.temp1 = v
        v = MinMaxAvg()
        v._decode(src)
        self.temp2 = v
        v = MinMaxAvg()
        v._decode(src)
        self.iout = v
        v = MinMaxAvg()
        v._decode(src)
        self.vout = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.vout._encode(dst)
            self.iout._encode(dst)
            self.temp2._encode(dst)
            self.temp1._encode(dst)
            self.status._encode(dst)


class LargeSystemPsu(SEQUENCE):
    max_size = 58
    __slots__ = (
        'status',
        'temp',
        'pout',
        'pout2',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = FixedPoint()
        v._decode(src)
        self.status = v
        v = MinMaxAvg()
        v._decode(src)
        self.temp = v
        v = MinMaxAvg()
        v._decode(src)
        self.pout = v
        v = MinMaxAvg()
        v._decode(src)
        self.pout2 = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.pout2._encode(dst)
            self.pout._encode(dst)
            self.temp._encode(dst)
            self.status._encode(dst)


class LargeSystemStatus(SEQUENCE):
    max_size = 1955
    __slots__ = (
        'version',
        'uptime_secs',
        'boardtemp',
        'psu',
        'pol',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 255)
        self.version = v
        v = src.next_INTEGER(0, 4294967295)
        self.uptime_secs = v
        src, save = src.next(TAG.SEQUENCE, FLAG.STRUCTURED), src
        a = []
        while not src.done():
            v = LargeSystemBoardTemp()
            v._decode(src)
            a.append(v)
        if len(a) < 1:
            raise ConstraintViolation(a)
        if len(a) > 4:
            raise ConstraintViolation(a)
        v, src = a, save
        self.boardtemp = v
        v = LargeSystemPsu()
        v._decode(src)
        self.psu = v
        src, save = src.next(TAG.SEQUENCE, FLAG.STRUCTURED), src
        a = []
        while not src.done():
            v = LargeSystemPol()
            v._decode(src)
            a.append(v)
        if len(a) < 1:
            raise ConstraintViolation(a)
        if len(a) > 24:
            raise ConstraintViolation(a)
        v, src = a, save
        self.pol = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
                for v in reversed(self.pol):
                    v._encode(dst)
            self.psu._encode(dst)
            with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
                for v in reversed(self.boardtemp):
                    v._encode(dst)
            dst.emit_INTEGER(self.uptime_secs)
            dst.emit_INTEGER(self.version)


class BroadcastReply(SEQUENCE):
    max_size = 5
    __slots__ = (
        'ok',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_BOOLEAN()
        self.ok = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_BOOLEAN(self.ok)


class BoardStatus(SEQUENCE):
    max_size = 107
    __slots__ = (
        'version',
        'uptime_secs',
        'hasher_stats',
        'pol_status',
        'current',
        'temp1',
        'temp2',
        'voltage',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 65535)
        self.version = v
        v = src.next_INTEGER(0, 4294967295)
        self.uptime_secs = v
        src, save = src.next(TAG.SEQUENCE, FLAG.STRUCTURED), src
        a = []
        while not src.done():
            v = HasherStatus()
            v._decode(src)
            a.append(v)
        if len(a) < 1:
            raise ConstraintViolation(a)
        if len(a) > 4:
            raise ConstraintViolation(a)
        v, src = a, save
        self.hasher_stats = v
        v = src.next_INTEGER(0, 65535)
        self.pol_status = v
        v = FixedPoint()
        v._decode(src)
        self.current = v
        v = Int16()
        v._decode(src)
        self.temp1 = v
        v = Int16()
        v._decode(src)
        self.temp2 = v
        v = FixedPoint()
        v._decode(src)
        self.voltage = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            self.voltage._encode(dst)
            self.temp2._encode(dst)
            self.temp1._encode(dst)
            self.current._encode(dst)
            dst.emit_INTEGER(self.pol_status)
            with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
                for v in reversed(self.hasher_stats):
                    v._encode(dst)
            dst.emit_INTEGER(self.uptime_secs)
            dst.emit_INTEGER(self.version)


class SubmitRequest(SEQUENCE):
    max_size = 48
    __slots__ = (
        'message_id',
        'jobid',
        'enonce2',
        'otime',
        'nonce',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 4294967295)
        self.message_id = v
        v = src.next_INTEGER(0, 4294967295)
        self.jobid = v
        v = src.next_OCTET_STRING(0, 16)
        self.enonce2 = v
        v = src.next_INTEGER(0, 4294967295)
        self.otime = v
        v = src.next_INTEGER(0, 4294967295)
        self.nonce = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_INTEGER(self.nonce)
            dst.emit_INTEGER(self.otime)
            dst.emit_OCTET_STRING(self.enonce2)
            dst.emit_INTEGER(self.jobid)
            dst.emit_INTEGER(self.message_id)


class BootStatus(SEQUENCE):
    max_size = 43
    __slots__ = (
        'version',
        'firmware_version',
        'boot_cause',
        'hw_init',
        'hw_verify',
        'crash_pc',
        'crash_lr',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 65535)
        self.version = v
        v = src.next_INTEGER(0, 4294967295)
        self.firmware_version = v
        v = src.next_INTEGER(0, 65535)
        self.boot_cause = v
        v = src.next_INTEGER(-2147483648, 2147483647)
        self.hw_init = v
        v = src.next_INTEGER(-2147483648, 2147483647)
        self.hw_verify = v
        v = src.next_OCTET_STRING(4, 4)
        self.crash_pc = v
        v = src.next_OCTET_STRING(4, 4)
        self.crash_lr = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_OCTET_STRING(self.crash_lr)
            dst.emit_OCTET_STRING(self.crash_pc)
            dst.emit_INTEGER(self.hw_verify)
            dst.emit_INTEGER(self.hw_init)
            dst.emit_INTEGER(self.boot_cause)
            dst.emit_INTEGER(self.firmware_version)
            dst.emit_INTEGER(self.version)


class LaminarClientMessage(CHOICE):
    max_size = 1959
    tags_f = {
        AuthRequest: 0,
        SubmitRequest: 1,
        BitsplitAuthRequest: 2,
        BroadcastReply: 4,
        BoardStatus: 99,
        BootStatus: 100,
        LargeSystemStatus: 29,
    }
    tags_r = {
        0: AuthRequest,
        1: SubmitRequest,
        2: BitsplitAuthRequest,
        4: BroadcastReply,
        99: BoardStatus,
        100: BootStatus,
        29: LargeSystemStatus,
    }


class UpdateCheck(SEQUENCE):
    max_size = 34
    __slots__ = (
        'info',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_OCTET_STRING(0, 30)
        self.info = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_OCTET_STRING(self.info)


class AuthReplyNo(SEQUENCE):
    max_size = 104
    __slots__ = (
        'error',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_OCTET_STRING(0, 100)
        self.error = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_OCTET_STRING(self.error)


class AuthReply(CHOICE):
    max_size = 110
    tags_f = {
        AuthReplyYes: 0,
        AuthReplyNo: 1,
        PoolDown: 2,
    }
    tags_r = {
        0: AuthReplyYes,
        1: AuthReplyNo,
        2: PoolDown,
    }


class SetDifficulty(SEQUENCE):
    max_size = 9
    __slots__ = (
        'difficulty',
    )

    def _decode(self, src):
        src = src.next(TAG.SEQUENCE, FLAG.STRUCTURED)
        v = src.next_INTEGER(0, 4294967295)
        self.difficulty = v
        src.assert_done()
        self.value = v

    def _encode(self, dst):
        with dst.TLV(TAG.SEQUENCE, FLAG.STRUCTURED):
            dst.emit_INTEGER(self.difficulty)


class LaminarServerMessage(CHOICE):
    max_size = 1128
    tags_f = {
        AuthReply: 0,
        SubmitReply: 1,
        Notify: 2,
        SetDifficulty: 3,
        BroadcastRequest: 4,
        UpdateCheck: 99,
    }
    tags_r = {
        0: AuthReply,
        1: SubmitReply,
        2: Notify,
        3: SetDifficulty,
        4: BroadcastRequest,
        99: UpdateCheck,
    }
