-- -*- Mode: asn1; indent-tabs-mode: nil -*-

LaminarModule DEFINITIONS ::= BEGIN

  Hash ::= OCTET STRING SIZE (32)
  Output ::= OCTET STRING SIZE (1..64)

  -- we divide into Client and Server messages to control
  --   code size on small embedded systems.

  LaminarClientMessage ::= CHOICE {
      auth-request          [0] AuthRequest,
      submit-request        [1] SubmitRequest,
      bitsplit-auth-request [2] BitsplitAuthRequest,
      broadcast-reply       [4] BroadcastReply,
      -- 21e6 proprietary --
      board-status          [99] BoardStatus,
      boot-status          [100] BootStatus,
      large-status          [29] LargeSystemStatus
  }

  LaminarServerMessage ::= CHOICE {
      auth-reply        [0] AuthReply,
      submit-reply      [1] SubmitReply,
      notify            [2] Notify,
      set-difficulty    [3] SetDifficulty,
      broadcast-request [4] BroadcastRequest,
      -- 21e6 proprietary --
      update-check      [99] UpdateCheck
  }

  -- Client: AuthRequest
  -- Server: AuthResponse
  AuthRequest ::= SEQUENCE {
      version INTEGER (0..255),
      username OCTET STRING SIZE (1..50),
      worker OCTET STRING SIZE (1..20),
      password OCTET STRING SIZE (1..50)
  }

  AuthReply ::= CHOICE {
      auth-yes  [0] AuthReplyYes,
      auth-no   [1] AuthReplyNo,
      pool-down [2] PoolDown
  }

  AuthReplyYes ::= SEQUENCE {
      enonce1 OCTET STRING SIZE (0..16),
      enonce2-size INTEGER (0..16)
  }

  AuthReplyNo ::= SEQUENCE {
      error OCTET STRING SIZE (0..100)
  }

  PoolDown ::= SEQUENCE {
      msg OCTET STRING SIZE (0..100),
      retry-seconds INTEGER (0..1800)
  }

  -- For data center stuff
  BroadcastMode ::= ENUMERATED {
      notify-only (0),
      notify-and-submit (1)
  }

  IPv4 ::= OCTET STRING (SIZE (4))
  IPv6 ::= OCTET STRING (SIZE (16))

  IPAddress ::= CHOICE {
    ipv4  [0] IPv4,
    ipv6  [1] IPv6
  }

  Address ::= SEQUENCE {
    ip IPAddress,
    port INTEGER (0..65535)
  }

  -- server requests that broadcast mode be turned on or off
  BroadcastRequest ::= SEQUENCE {
      mode BroadcastMode,
      address Address
  }

  -- server replies with the current broadcast port
  BroadcastReply ::= SEQUENCE {
      ok BOOLEAN
  }

  SubmitRequest ::= SEQUENCE {
      message-id INTEGER (0..4294967295),
      jobid INTEGER (0..4294967295),
      enonce2 OCTET STRING SIZE (0..16),
      otime INTEGER (0..4294967295),
      nonce INTEGER (0..4294967295)
  }

  SubmitStatus ::= ENUMERATED {
      good (0),
      bad (1),
      stale (2),
      duplicate (3)
  }

  SubmitReply ::= SEQUENCE {
      message-id INTEGER (0..4294967295),
      result SubmitStatus
  }

  -- Sent from server. No reponse from the client --
  Notify ::= SEQUENCE {
      jobid INTEGER (0..65535),
      block-version INTEGER (0..65535),
      prev Hash,
      height INTEGER (0..4294967295),
      bits INTEGER (0..4294967295),
      itime INTEGER (0..4294967295),
      iscript0 OCTET STRING SIZE (0..100),
      iscript1 OCTET STRING SIZE (0..100),
      outputs SEQUENCE SIZE (1..5) OF Output, -- NOTE: shrunk (1..300)
      edge SEQUENCE SIZE (0..15) OF Hash,
      clear BOOLEAN
  }

  -- Sent from client no reply --
  SetDifficulty ::= SEQUENCE {
      difficulty INTEGER (0..4294967295)
  }

  -- bitsplit-specific
  -- BitsplitAuthRequest should be renamed BitshareAuthRequest.
  -- But the difference is having the client send particulars about their split percentage as part of the auth.
  -- AuthRequest is for non-bitshare systems/chips.
  -- For example, chargers and rpi have to BitsplitAuthRequest while our datacenters use AuthRequest.
  -- The chips built for the datacenters are non-bitsplit/bitshare.
  BitsplitAuthRequest ::= SEQUENCE {
      version INTEGER (0..255),
      uuid OCTET STRING SIZE (16),
      mac OCTET STRING SIZE (6),
      protocol INTEGER (0..4294967295),
      numerator INTEGER (0..100),
      denominator INTEGER (0..100)
  }

  -- 21e6 proprietary

  -- fixed-point x.yy
  FixedFloat ::= INTEGER (0..65535)

  HasherStatus ::= SEQUENCE {
      freq FixedFloat,
      good-cores OCTET STRING SIZE (8)
  }

  BoardStatus ::= SEQUENCE {
      version INTEGER (0..65535),
      uptime-secs INTEGER (0..4294967295),
      hasher-stats SEQUENCE SIZE (1..4) OF HasherStatus,
      pol-status INTEGER (0..65535),
      current FixedFloat,
      temp1   FixedFloat,
      temp2   FixedFloat,
      voltage FixedFloat
  }

  BootStatus ::= SEQUENCE {
      version          INTEGER (0..65535),
      firmware-version INTEGER (0..4294967295),
      boot-cause       INTEGER (0..65535),
      hw-init          INTEGER (-2147483648..2147483647),
      hw-verify        INTEGER (-2147483648..2147483647),
      crash-pc         OCTET STRING SIZE (4),
      crash-lr         OCTET STRING SIZE (4)
  }

  MinMaxAvg ::= SEQUENCE {
    min   FixedFloat,
    max   FixedFloat,
    avg   FixedFloat
  }

  LargeSystemPol ::= SEQUENCE {
      status      FixedFloat,
      temp1       MinMaxAvg,
      temp2       MinMaxAvg,
      iout        MinMaxAvg,
      vout        MinMaxAvg
  }

  LargeSystemBoardTemp ::= SEQUENCE {
      temp  MinMaxAvg
  }

  LargeSystemPsu ::= SEQUENCE {
      status      FixedFloat,
      temp        MinMaxAvg,
      pout        MinMaxAvg,
      pout2       MinMaxAvg
  }

  LargeSystemStatus ::= SEQUENCE {
      version INTEGER (0..255),
      uptime-secs INTEGER (0..4294967295),
      boardtemp SEQUENCE SIZE (1..4) OF LargeSystemBoardTemp,
      psu LargeSystemPsu,
      pol SEQUENCE SIZE (1..24) OF LargeSystemPol
  }

  -- tell the device to check for a firmware upgrade
  UpdateCheck ::= SEQUENCE {
      info OCTET STRING SIZE(0..30)
  }

END
